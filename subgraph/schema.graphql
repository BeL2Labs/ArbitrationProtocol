enum ArbiterStatus {
    Active     # Arbiter is available for new transactions
    Working    # Arbiter is currently working on a transaction
    Paused     # Arbiter is temporarily paused
    Terminated  # Arbiter has been terminated
}

enum DAppStatus {
    None
    Pending
    Active
    Suspended
    Terminated
}

enum TransactionStatus {
    Active
    Completed
    Arbitrated
    Expired
    Disputed
}

enum CompensationType {
    Unknown
    IllegalSignature,
    Timeout,
    FailedArbitration,
    ArbiterFee
}

type ArbiterInfo @entity {
    id: ID! # required by the graph
    createdAt: Int! # Timestamp, DB side only, not on chain - block time at which the arbiter info was first found (first event)
    lastArbitrationTime: Int # Timestamp at which this arbiter term ends
    address: String! @id # Arbiter Ethereum address
    currentFeeRate: Int # Current fee rate
    pendingFeeRate: Int # Pending new fee rate
    status: ArbiterStatus! # Arbiter status
    activeTransactionId: Bytes # ID of the transaction that made the arbiter "working". 0 address if not working.
    ethAmount: BigInt! # Native token stake amount
    erc20Token: String # ERC20 token address
    nftContract: String # NFT contract address
    nftTokenIds: [BigInt!] # NFT token IDs
    
    # Operator
    operatorEvmAddress: String # Operator EVM address
    operatorBtcPubKey: String # Bitcoin public key
    operatorBtcAddress: String # Bitcoin address

    # Revenue
    revenueEvmAddress: String # Revenue EVM address
    revenueBtcPubKey: String # Bitcoin public key
    revenueBtcAddress: String # Bitcoin address
}

type Transaction @entity {
    id: ID! # required by the graph
    createdAt: Int! # Timestamp, DB side only, not on chain - block time at which the transaction was first found (first event)
    txId: String! # Transaction ID, same as ID
    dapp: String # DApp address
    arbiter: String
    startTime: Int
    deadline: Int
    btcTx: Bytes # Unsigned Bitcoin transaction
    btcTxHash: Bytes # Hash of the Bitcoin transaction with empty input scripts
    status: TransactionStatus!
    depositedFee: BigInt
    signature: Bytes # Arbiter's signature
    compensationReceiver: String
    timeoutCompensationReceiver: String
}

type ArbitrationRequest @entity {
    id: ID!
    txId: BigInt!
    requester: String!
    requestTime: Int!
    deadline: Int!
    timeoutCompensationReceiver: String!
    fulfilled: Boolean!
}

type CompensationClaim @entity {
    id: ID!
    createdAt: Int! # Timestamp, DB side only, not on chain - block time at which the compensation was first found (first event)
    claimer: String
    claimType: CompensationType!
    withdrawn: Boolean!
    arbiter: String
    amount: BigInt
    evidence: Bytes
}

type DApp @entity {
    id: ID!
    createdAt: Int! # Timestamp, DB side only, not on chain - block time at which the dapp was first found (first event)
    address: String!
    owner: String
    status: DAppStatus!
}

type BPosNFT @entity {
    id: ID!
    createdAt: Int! # Timestamp, DB side only, not on chain - block time at which the bpos nft was first found (first event)
    owner: String! # EVM address
    tokenId: BigInt!
}